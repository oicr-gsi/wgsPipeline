#!/usr/bin/perl -w

=head2 SUMMARY
 
 Script for filtering and clustering genotypes, splitting matrix into a set of smaller chunks and producing html report with images

=head2 USAGE

 make_report.pl --datadir [required] --studyname [required] --matrix [required] --refsnps [required] --tempdir [optional]

 Script requires similarity matrix (tab-delimited), directory with data (vcf files) studyname and number of control points (SNPs)
 Optionally it uses tempdir parameter which may point to a directory with coverage depth data if that is different than datadir

=head2 EXAMPLES

 ./make_report.pl --matrix PCSI_WG.matrix.all.txt --datadir . --tempdir ./GATK.out/PCSI_EX.depth/ --studyname PCSI --refsnps 400 > index.html

 ./make_report.pl --matrix PCSI_EX.matrix.all.txt --datadir blah/ --studyname PCSI --refsnps 400 > PCSI_test.html 

=cut

# =================================================================================================================
# Script for filtering and clustering genotypes, splitting matrix into a set of smaller chunks and producing images 
# + html wrapper
# =================================================================================================================

use strict;
use POSIX qw(floor);
use Getopt::Long;
use CGI qw/:standard/;
use IO::File;
use FindBin qw($Bin);
use Data::Dumper;

use constant THRESHOLD=>30; # That many SNPs every genotype should have
use constant DEBUG=>0;
use constant NOGARBAGE=>1; # Filter (or not) entries that have only 1 or/and 0
use constant SAMPLESPERSLICE=>8;
use constant JACCARDOFFSET=>0.1; # Allow lanes to be reassigned to their parent cluster if they similarity to the lanes from other donors is not that great

my($datadir,$tempdir,$matrix,$studyname,$refsnps,$singles_ok); # external parameters
my($snp_index,%samples,%sample_counter,%ids,%filtered,@lines,%reports); # internal variables
my %flagged = (samples=>{}, files=>{});
my $pngsize = 750;

# ===== Swap Detection variables =========
my %n; #Parsed Dendrogram Nodes
my @leafs_found;
my @ids_tested;

=head2 reports hash structure

 reports (for each slice) should contain these data:

 img      => image of the heatmap
 fp       => image of the fingerprints
 title    => title that should list all samples in the cluster
 matrix   => path to file with similarity matrix (jaccard indexes) for a heatmap
 genotype => path to file with genotype info for a heatmap

=cut

my @colors = qw/red orange yellow green lightblue blue purple darkgreen black pink/; 
my $USAGE  = "make_report.pl --datadir=[req] --studyname=[req] --matrix=[req] --refsnps=[req] --tempdir=[opt]";
my $result = GetOptions ('datadir=s'    => \$datadir, # working (output) directory
                         'tempdir=s'    => \$tempdir,  # directory with temporary GATK files
                         'matrix=s'     => \$matrix,  # file with calculated indexes
                         'refsnps=i'    => \$refsnps, # number of SNPs in reference checkpoint list
                         'allow-singletons|singletons-ok' => \$singles_ok,
                         'studyname=s'  => \$studyname);
if (!$matrix || !$refsnps || !$studyname ) { die $USAGE; }
# First step -load the data, filter files with not enogh SNPs 
$datadir.="/" if $datadir !~m!/$!;
$tempdir ||=$datadir;
$tempdir.="/" if $tempdir !~m!/$!;
print STDERR "Singletons allowed!\n" if DEBUG && $singles_ok;

# =====================================================================================
# Reading from the matrix generated by the workflow (csv format, provisioned)
# =====================================================================================
if ($matrix && -e $matrix) {
 my $fh = new IO::File("<$matrix") or die "There was an error reading file [$matrix]";
 my $firstline = <$fh>;
 $firstline=~s/^0*//; # Funny entries should be removed by this command
 chomp($firstline);
 my @heads = split("\t",$firstline);
 map {if ($heads[$_]=~/^SNP/){$snp_index = $_}} (0..$#heads);

 $snp_index or die "The matrix file [$matrix] is missing the column with number of SNPs called per genotype";
 @lines = ($firstline);

 # Find what is the index of 'SNPs' column and use it later to remove those entries with fewer than THRESHOLD SNPs
 while (<$fh>) {
  chomp;
  my @temp = split("\t");
  my $trimmed_name = $temp[0];
  if ($trimmed_name =~/^SWID/) {
     $trimmed_name=~s/(SWID_\d+)_(.*)/$2\_$1/;
  }
  my $notgarbage = 1;
  if (NOGARBAGE) {
    my %checkhash = ();
    map {$checkhash{$temp[$_]}++ if ($temp[$_] ne "1" && $temp[$_] ne "0.000")} (1..$snp_index-1);
    if (scalar(keys %checkhash) == 0) {
     print STDERR "Detected Garbage Row\n" if DEBUG;
     $notgarbage = 0;
    } 
  }

  if ($temp[$snp_index] && $temp[$snp_index] >= THRESHOLD && $notgarbage && $trimmed_name=~/(\w{3,6}_\d+)_/ ) { 
    $ids{$temp[0]} = $trimmed_name;
    $samples{$ids{$temp[0]}} = {sample=>$1,file=>$temp[0],name=>$trimmed_name}; # register a file as pertaining to a certain sample (studyname_sampleid)
    $sample_counter{$1}++; 

    push(@lines,join("\t",@temp));
  } else {
    $filtered{$temp[0]} = $trimmed_name;
    next;
  }
 } # reading from matrix ends here

 $fh->close;
 print STDERR "Files: ".scalar(keys %ids)." in ".scalar(keys %sample_counter)." samples\n" if DEBUG;

 # Post-filtering: register filtered files as skipped
 # Open a file for writing out filtered matrix (with friendlier file ids):
 my $mfile = $datadir."matrix_filtered.csv";
 $fh->open(">$mfile") or die "Couldn't write filtered data into a file [$mfile]";
 
 my @filterhead;
 
 HEAD:
 foreach my $hf (@heads) {
  if ($filtered{$hf}) {next;}
  push(@filterhead,$hf) if $hf=~/\w+/;
 }
 print STDERR "Filtered header retained ".scalar(@filterhead)." of ".scalar(@heads)." original ones, skipped indexes: ".scalar(keys %filtered)."\n" if DEBUG;

 map{print $fh "\t".$ids{$_} if $ids{$_}} (@filterhead);
 print $fh "\tSNPs\n";
 
 # Get read of filtered files (lines in the matrix)
 LINE:
 foreach my $line (@lines) {
  my @tlines = split("\t",$line);
  if ($line =~/^(\S+)\t/) {
    if ($filtered{$tlines[0]}){next LINE;}

    print $fh $ids{$tlines[0]};     # Trimmed  name is printed into matrix_filtered.csv
    IDX:
    foreach my $line_idx (1..$#tlines) {
      if ($filtered{$heads[$line_idx]}) {next IDX;}
       if ($tlines[$line_idx] =~/NA/) {
           print $fh "\t0";
       } else {
           print $fh "\t$tlines[$line_idx]";
       }
    }
        
  } else {
    next LINE;
  }
  print $fh "\n";
  }
  $fh->close;

} else {
 die "No valid matrix file supplied, I cannot continue with no input";
}

=head2 

 Using R (heatmap) cluster samples, 
 we need the re-arranged list for next step

 We need this step to see which donors (samples) cluster 
 together so that we can distribute donors more precisely 
 among final clusters

=cut

my $ordered      = `Rscript $Bin/cluster.r $datadir/matrix_filtered.csv`;
my @ordered_list = split(" ",$ordered);
print STDERR "Got ".scalar(@ordered_list)." files ordered by clustering\n" if DEBUG;

my %indexed_lines = ();
my %seen_sample   = ();
my %sperslice     = (); # samples per slice, calculate and compare with sample_counter (if no match, there's b/w slices sample split
my %sliced        = ();
my %parent_clusters = (); # keys are samples, values are number of files in the parent cluster
my $count   = 0; # slice counter

map{if(/(\S+)\t/ && $ids{$1}){$indexed_lines{$ids{$1}} = $_}} @lines;
print STDERR "Got ".scalar(keys %indexed_lines)." indexed lines\n" if DEBUG;
my %preclusters = ();

# ======================================================================================
# Pre-clustering step, need to re-assign lanes to parent cluster if needed
# pre-clustering results should be used to assemble final clusters for creating heatmaps
# ======================================================================================
my $current_sample;
print STDERR "Found ".scalar(@ordered_list)." lines in ordered list\n" if DEBUG;
ORDERED:
foreach my $id (@ordered_list) {
 if (!$samples{$id}) {next ORDERED;}
 if (!$singles_ok && $sample_counter{$samples{$id}->{sample}} < 2) {
  $filtered{$samples{$id}->{file}} = $samples{$id}->{name}; # Skip all files which are single representatives of their sample
  next ORDERED;
 }
 $current_sample ||=$samples{$id};
 $count++ if ($current_sample ne $samples{$id});

 $preclusters{$count}->{$id}++;
 $sperslice{$count}->{$samples{$id}->{sample}}++;

 if (!$parent_clusters{$samples{$id}->{sample}} || $sperslice{$count}->{$samples{$id}->{sample}} > $parent_clusters{$samples{$id}->{sample}}->{max}) {
         $parent_clusters{$samples{$id}->{sample}} = {max=>$sperslice{$count}->{$samples{$id}->{sample}},cluster=>$count};
 }
}
print STDERR "Found ".scalar(keys %preclusters)." preclusters\n" if DEBUG;

=head2

 Entries that don't show strong affinity to any foreign clusters
 may get re-assigned to their 'parent' clusters so that the data
 stay together (it may be investigated more later using webtool)

=cut 

my $headerline = $lines[0];

foreach my $cl (sort {$a<=>$b} keys %preclusters) {
   foreach my $file_id (keys %{$preclusters{$cl}}) {
     if ($parent_clusters{$samples{$file_id}->{sample}}->{cluster}!=$cl) {
         # Retrieve the lines for all files pertaining to the sample 
         my @clines = ($headerline,$indexed_lines{$file_id});
         my @plines = @clines;
         map{push(@plines,$indexed_lines{$_}) if $samples{$_}->{sample} eq $samples{$file_id}->{sample}} (keys %{$preclusters{$parent_clusters{$samples{$file_id}->{sample}}->{cluster}}});
         
         # this may need to be handled differently (perhaps not here, but on the level of R script that build the heatmap)
         if (&aver_ji(\@plines,$samples{$file_id}->{sample},1) >= &aver_ji(\@clines,$samples{$file_id}->{sample},0) - JACCARDOFFSET) {
             # Reassign to parent cluster:
             print STDERR $file_id." gets reassigned to its parent cluster\n" if DEBUG;
             $preclusters{$cl}->{$file_id} = undef;
             $preclusters{$parent_clusters{$samples{$file_id}->{sample}}->{cluster}}->{$file_id}++;
         } 

     }
  }
}

=head2 Composing Slices
 
 Here we composing slices for final clustering and making images
 Checking N samples per cluster, re-assigning if needed
 (and if it's possible)

=cut

%sperslice = ();
my $slice_id = 0;
PRE:
foreach my $pre (sort {$a<=>$b} keys %preclusters) {
 map{if(!defined($preclusters{$pre}->{$_})){next PRE}} (keys %{$preclusters{$pre}});
 if ($sperslice{$slice_id} && scalar(keys %{$sperslice{$slice_id}}) >= SAMPLESPERSLICE) {
  $slice_id++;
 }

 foreach my $file_id (keys %{$preclusters{$pre}}) {
  $sperslice{$slice_id}->{$samples{$file_id}->{sample}}++;
  $sliced{$slice_id}->{$file_id}++;
 }
}

=head2 If the last cluster is small

 Append last cluster to last-1 cluster if there's 
 only one (or two) sample in the last one

=cut

if (scalar(keys %{$sperslice{scalar(keys %sliced)-1}}) <= 2 && scalar(keys %sliced) > 1) {
 foreach my $f (keys %{$sliced{scalar(keys %sliced)-1}}) {
  $sliced{scalar(keys %sliced)-1}->{$f} = undef;
  $sliced{scalar(keys %sliced)-2}->{$f}++;
 }
 map {$sperslice{scalar(keys %sliced)-2}->{$_}++} (keys %{$sperslice{scalar(keys %sliced)-1}});
 $sliced{scalar(keys %sliced)-1} = undef;
}


=head2 Now print all slices 

 Slices are processed one by one
 Swap detection happens inside printout_slice function

 At this point we are basically done, printing out HTML

=cut

foreach my $sl (sort {$a<=>$b} keys %sliced) {
 next if !$sliced{$sl};
 $sperslice{$sl} = {};
 my @slicelines = ($lines[0]);

 foreach my $oid(@ordered_list) {
   next if !$sliced{$sl}->{$oid};
   $sperslice{$sl}->{$samples{$oid}->{sample}}++;
   push(@slicelines,$indexed_lines{$oid}) if $indexed_lines{$oid};
 }
 if (scalar(keys %{$sperslice{$sl}}) == 0){next;} # Skip non-existing clices
 my $t = join(",",(keys %{$sperslice{$sl}})); # Title
 print STDERR "MY TITLE: $t\n" if DEBUG;
 &printout_slice($sliced{$sl},$sl,\@slicelines,join("_",($studyname,$sl)),$datadir,$t);
 &printout_snps($sliced{$sl},$sl,join("_",($studyname,$sl)),$datadir);
}

&printout_html;

=head2 printout_html 

 make HTML report (will call a couple of subroutines)

=cut

sub printout_html {

 print start_html(-title=>'Sample Fingerprinting Report',
                  -author=>'pruzanov@oicr.on.ca',
                  -meta=>{'keywords'=>'sample swap detection genotype fingerprinting',
                                      'copyright'=>'&copy; 2013 OICR'},
                  -script=>[{-type  => 'text/javascript',
                             -code  => 'function showFingerprints(snapshot){window.open(snapshot,"_blank","width='.($pngsize + 1).',height=600,toolbar=0,menubar=0,status=1,scrollbars=yes,resizable=1")}'}],
                  -BGCOLOR=>'white');

 print button(-onClick=>"showFingerprints('help.html')",
              -name=>"help_button",
              -value=>"Help");

 print "\n&nbsp;&nbsp;\n";
 my $matrix_link = $matrix;
 $matrix_link=~s!.*/!!;
 print button(-onClick=>"window.location.href=\'$matrix_link\'",
              -name   =>"download_button",
              -value  =>"Download Data");
 print h2("Sample Fingerprinting for ".$studyname." study");
 print br;
 #1. Suspicious samples
 if (scalar(keys %{$flagged{files}}) > 0) {
  my @flagged = map{if (defined $flagged{files}->{$_}){Tr({-align=>'LEFT',-valign=>'BOTTOM'},td($_))}} (sort keys %{$flagged{files}});

  print h3("Files flagged as potential sample swaps:");
  print br;
  print table({-border=>0},
               @flagged);
}


 #2. Filtered files:
 if (scalar(keys %filtered) > 0) {
  my @filtered = map{Tr({-align=>'LEFT',-valign=>'BOTTOM'},td($_))} (sort values %filtered);

  print h3("Files skipped due to low coverage/small number of SNPs or single file in a sample:");
  print br;
  print table({-border=>0},
               @filtered);
 }


 # Define table = 3 columns always, rows - depending on the number of heatmaps
 my $n_rows = scalar(keys %reports)/3;
 $n_rows = int($n_rows) < $n_rows ? int($n_rows + 1) : int($n_rows);

 # 3. image of the heatmap and 4. button with a link to popup with fingerprints
 my @hmaps = map {&heatmap_rep($_)} (sort {$a<=>$b} keys %reports);
 my @tab_rows = map {3*$_+2 <= $#hmaps ? Tr({-align=>'LEFT',-valign=>'TOP'},@hmaps[3*$_..3*$_+2])
                                       : Tr({-align=>'LEFT',-valign=>'TOP'},@hmaps[3*$_..$#hmaps]);} (0..$n_rows-1);

 print h3("Heatmaps based on similarity matricies:");
 print table({-border=>0},
              @tab_rows);

 print end_html;
}

=head2 printout_snps

 A subroutine for printing out genotype report for a heatmap (slice) - will list all SNPs in checked 'hotspots' in a table

=cut

sub printout_snps {
 my %sliced = %{shift @_};
 my($slice_id,$filecard,$datadir) = @_;

 # Open .fin file and read info from there, build matrix for all files in the slice and print into a file
 my $fh_fin = new IO::File();
 my %snpinfo;
 my %snpcalls;
 my @titles = (); # Cell titles

 foreach my $id (sort keys %sliced) {
  my $finfile = $tempdir.$samples{$id}->{file}.".fin";

  my $file_ok = 1;
  $fh_fin->open($finfile) or $file_ok = 0;
  if (!$file_ok) {
   warn "File with snp info for $id is not available";
   next;
  }
  
  my $first = <$fh_fin>;
  if ($first!~/^CHROM/){next;}

  @titles = split("\t",$first) if !@titles;
  my $filename = $samples{$id}->{file};
  while (<$fh_fin>) {
   chomp;
   my @temp = split("\t");
   my $snp_start = $temp[1]=~/\D/ ? $` : $temp[1];
   $snpinfo{$temp[0]}->{$snp_start} ||= $temp[2];
   $snpcalls{$temp[2]}->{$samples{$id}->{file}} = $temp[3];
  }
  $fh_fin->close;
 }

 # Having collected all snp calls from the .fin files let's create a genotype report file
 my $fname = join("_",($studyname,$slice_id,"genotype_report_$$.csv"));
 my $fpath = $datadir.$fname;
 $fh_fin->open(">$fpath") or die "Couldn't write genotype report to [$fpath]";
 print $fh_fin join("\t",@titles[0..2]) if @titles;
 my @fnames = map{$samples{$_}->{name}} (sort keys %sliced);
 print $fh_fin "\t",join("\t",@fnames),"\n";

 foreach my $chrom (sort keys %snpinfo) {
  foreach my $pos (sort {$a<=>$b} keys %{$snpinfo{$chrom}}) {
   print $fh_fin join("\t",($chrom,$pos,$snpinfo{$chrom}->{$pos}));
   foreach my $file_id (sort keys %sliced) {
    $snpcalls{$snpinfo{$chrom}->{$pos}}->{$samples{$file_id}->{file}} ? print $fh_fin "\t".$snpcalls{$snpinfo{$chrom}->{$pos}}->{$samples{$file_id}->{file}} : print $fh_fin "\t"; 
   }
   print $fh_fin "\n";
  }
 }
 $fh_fin->close;
 $reports{$slice_id}->{genotype} = $fname;

}

=head2 printout_slice

 process slices with two R scripts - one for heatmap, one for 'barcode'-looking fingerprint
 Here we are printing to two files, slightly different header and file ids

=cut

sub printout_slice {
 my %sliced = %{shift @_};
 my $slice_id = shift @_;
 my %colors;
 my @lines  = @{shift @_};
 print STDERR "Got ".scalar(@lines)." lines for cluster $slice_id\n" if DEBUG;
 return if scalar(@lines) <= 1;
 my($filecard,$datadir,$pngtitle,$flagged) = @_;
 $flagged ||="FALSE";

 # Temporary matrix file for a slice
 my $outfile = $datadir.$filecard."_$$.csv";
 my $matname = $filecard."_similarity_matrix_$$.csv";
 my $matfile = $datadir.$matname;
 print STDERR "Writing to the file [$outfile] ".(keys %sliced)." datapoints\n" if DEBUG;
 my $fo = new IO::File(">$outfile") or die "Cannot write to file [$outfile]";
 my $fm = new IO::File(">$matfile") or die "Cannot write to file [$matfile]";
 my $first = shift @lines;
 my @names = split "\t",$first;
 shift @names; # remove 1st (useless) element

 my %indexes;
 my $colcount = 0;
 
 NAME:
 for (my $i = 0; $i < @names; $i++) {
  if ($ids{$names[$i]} && $sliced{$ids{$names[$i]}}) {
   print $fo "\t".$ids{$names[$i]};
   $names[$i]=~s!.*/!!;
   print $fm "\t".$samples{$ids{$names[$i]}}->{name};

   $indexes{$i} = $ids{$names[$i]};
   $colors{$samples{$ids{$names[$i]}}->{sample}} ||= $colors[$colcount++];
  }
 }
 print STDERR "Assigned ".scalar(keys %colors)." colors to clusters\n" if DEBUG;
 print $fo "\tSNPs\tColor\n";
 print $fm "\tSNPs\n";

 # Main body of the matrix:
 foreach (@lines) {
  chomp;
  my @temp = split("\t");
  print $fo $ids{$temp[0]};
  $temp[0]=~s!.*/!!; # remove path, leave the name
  my $col = $colors{$samples{$ids{$temp[0]}}->{sample}};
  print $fm $samples{$ids{$temp[0]}}->{name};
  
  foreach my $idx(sort {$a<=>$b} keys %indexes) {
   if ($temp[$idx + 1] ne "NA") {
      print $fo "\t".$temp[$idx + 1];
      print $fm "\t".$temp[$idx + 1];
   } else {
      print $fo "\t0";
      print $fm "\tNA";
   }
  }

  print $fo "\t".$temp[$snp_index];
  print $fm "\t".$temp[$snp_index];
  print $fo "\t".$col;
  print $fo "\n";
  print $fm "\n";

 }
 $fo->close;
 $fm->close;

 # Produce images
 my $png = $datadir.$filecard.".png";
 print STDERR "Will Rscript $Bin/create_heatmap.r $outfile $pngtitle $refsnps $png $pngsize $flagged FALSE\n" if DEBUG;
 my $clustered_ids = `Rscript $Bin/create_heatmap.r $outfile $pngtitle $refsnps $png $pngsize $flagged FALSE`;
 my @clustered_ids = grep {/\S+/}  map {if(/^(\w{3,6}_\d+)_/ && $sample_counter{$1}){$_}} split(" ",$clustered_ids); 
 print STDERR "=====Clustered IDs:======\n" if DEBUG;
 print STDERR Dumper(@clustered_ids) if DEBUG;

=head2 Swap Detection
 
 New swap-marking algorithm that would use dendrogram from heatmap - drawing script
 An algoritm checks if we have all (or at least > 1/2 nodes for donor connected, unmarks
 swap for connected files. Initially, all files and donors are marked as swapped

 --[dendrogram w/ 2 branches and 26 members at h = 1.44]
  |--[dendrogram w/ 2 branches and 12 members at h = 1.2]
  |  |--[dendrogram w/ 2 branches and 4 members at h = 0.934]
  |  |  |--[dendrogram w/ 2 branches and 2 members at h = 0.0899]
  |  |  |  |--leaf "JDRT_0032_nn_T_PE_289_EX_150305_D00353_0095_AC6DN8ANXX_ACGTATCA_L001_R1_001_SWID_1547258" ( value = NA )
  |  |  |  `--leaf "JDRT_0032_nn_T_PE_289_EX_150325_D00343_0082_BC6DRRANXX_ACGTATCA_L003_R1_001_SWID_1659864" ( value = NA )
  |  |  `--[dendrogram w/ 2 branches and 2 members at h = 0.177]
  |  |     |--leaf "JDRT_0083_nn_T_PE_366_EX_150423_D00353_0101_AC6JH4ANXX_CGAACTTA_L001_R1_001_SWID_1793397" ( value = NA )
  |  |     `--leaf "JDRT_0083_nn_T_PE_366_EX_150423_D00353_0101_AC6JH4ANXX_CGAACTTA_L002_R1_001_SWID_1793396" ( value = NA )
  |  `--[dendrogram w/ 2 branches and 8 members at h = 0.98]
  ....

  Algo:
  
  %nodes (keys - integers, autoincrimented)
  
  a sample node:
  ...
  {
   dist     => 0.25,
   branches => [ids, may be undef]
   leafs    => [files, maybe undef]
  }
  ...

  Build nodes, sort by id and getLeafs from each sub-tree, noting node ids
  if N of files = N total for donor (and there's one donor in subtree) mark as OK

  if there's one donor and N <= 1/2 of total, leave marked as swapped, note the nodes to avoid repeat processing
 
=cut


 print STDERR "Rscript $Bin/create_heatmap.r $outfile $pngtitle $refsnps NoPngPlease $pngsize FALSE TRUE\n" if DEBUG;
 my @Dendro = `Rscript $Bin/create_heatmap.r $outfile $pngtitle $refsnps NoPngPlease $pngsize FALSE TRUE`;

 print STDERR scalar(@Dendro)." Lines in dendrogram\n" if DEBUG;
 %n = %{&getNodes(\@Dendro)};
 @leafs_found = ();
 @ids_tested  = ();
 my %valid_nodes = ();


 SWAPTEST:
 foreach my $test_id(sort {$a<=>$b} keys %n) { 
  print STDERR "\n\nLeafs requested for ID $test_id...\n" if DEBUG;
  @leafs_found = ();
  @ids_tested = ();
 
  if ($valid_nodes{$test_id}) {
   print STDERR "Node [$test_id] was tested before and found valid, will skip the tests\n" if DEBUG;
   next SWAPTEST;
  }

  &getLeafs($test_id);
  if (@leafs_found > 0) {
    print STDERR "===== Id: $test_id =====\n" if DEBUG;
    map {print STDERR $_."\n"} (@leafs_found) if DEBUG;

   #====================Validation Code=================
  
   my $swap = isSwapPresent($test_id, \@leafs_found); 
   if ($swap) {
     print STDERR "Swap detected for [$test_id]\n" if DEBUG;
   } else {
     print STDERR "No swap detected for [$test_id]\n" if DEBUG;
     map{$flagged{files}->{$_} = undef;} @leafs_found;
     map{$valid_nodes{$_}++} @ids_tested;
   }
 
  }
 }

 #=============End of swap-checkiing code=================


 my @fingers = ();
 my %seen_sample = (); # Re-use this hash for calculating
 my %maxfiles = ();    # maximum number of files in a sample (donor) on this heatmap. 'Max' cluster doesn't get marked may be obsolete after GP-393
 my $current_sample;
 my $lbuffer = [];     # lane buffer - for holding files in a cluster

 # Checking for broken clusters and generating fingerprint glyphs
 # Re-shuffle pngtitle so that order reflects clustered order
 my @titlebuf = ();

 for (my $cl = 0; $cl < @clustered_ids; $cl++) { 
  $current_sample = $samples{$clustered_ids[$cl]}->{sample};
  unless($seen_sample{$current_sample}) {push @titlebuf,$current_sample;}
  $seen_sample{$current_sample} ||= [];
  $maxfiles{$current_sample} ||= 0;
  
  if ($current_sample && $samples{$clustered_ids[$cl]}->{sample} && $current_sample ne $samples{$clustered_ids[$cl]}->{sample}) {
    push(@{$seen_sample{$current_sample}},$lbuffer);
    if ($maxfiles{$current_sample} < scalar(@{$lbuffer})){$maxfiles{$current_sample} = scalar(@{$lbuffer});}
    $lbuffer = [];
    $current_sample = $samples{$clustered_ids[$cl]}->{sample};
  }
  push(@{$lbuffer},$clustered_ids[$cl]);  
  

  ID:
  foreach my $id (keys %ids) {
   if($ids{$id} eq $clustered_ids[$cl]){
    $png = $ids{$id}.".fp".".png";
    push(@fingers,{img=>$png,
                   name=>$samples{$ids{$id}}->{name}});
    $png = $datadir.$png;
    my $fin = $id.".fin";
    $fin =~s!.*/!!;
     print STDERR "Will Rscript $Bin/create_fingerprints.r $tempdir $fin $colors{$samples{$clustered_ids[$cl]}->{sample}} $refsnps $png\n" if DEBUG;
     `Rscript $Bin/create_fingerprints.r $tempdir $fin $colors{$samples{$clustered_ids[$cl]}->{sample}} $refsnps $png`;
    last ID;
   } 
  }
 }
 

 if (scalar(@{$lbuffer}) > 0) {
  push(@{$seen_sample{$current_sample}},$lbuffer);
  if (!$maxfiles{$current_sample} || $maxfiles{$current_sample} < scalar(@{$lbuffer})){$maxfiles{$current_sample} = scalar(@{$lbuffer});}
 }

 # Register the image name in the report hash
 $reports{$slice_id} = {img    => $filecard.".png",
                        fp     => [@fingers],
                        matrix => $matname,
                        title  => join(",",@titlebuf)};
}

# ====================================================================================================================
# Average Jaccard index for a set of lines (if sample variable passed, only values for files from the sample processed) 
# ====================================================================================================================
sub aver_ji {
 
 # If there's no sample, will use all values exept 1 (genotype compared with itself)
 my($lines,$sample,$include) = @_;
 my @values = ();
 my $first = shift @{$lines};
 my @names = grep {/\S+/} split "\t",$first; 

 my %indexes;
 if ($sample) {
  NAME:
  for (my $i = 0; $i < @names; $i++) {
   if ($ids{$names[$i]} && $samples{$ids{$names[$i]}}->{sample} eq $sample) {
    $indexes{$i} = $ids{$names[$i]};
   }              
  }
 }

 foreach my $line (@{$lines}) {
   chomp($line);
   my @temp = split("\t",$line);
   if (%indexes) {
    if ($include) {
     map{if ($temp[$_ + 1] ne "1" && $temp[$_ + 1] ne "NA"){push(@values,$temp[$_ + 1])}} (sort {$a<=>$b} keys %indexes);
    } else {
     map{if (!$indexes{$_} && $temp[$_ + 1]=~/\d+/ && $temp[$_ + 1] ne "1" && $temp[$_ + 1] ne "NA"){push(@values,$temp[$_ + 1])}} (1..($snp_index-2));
    }
   } else {
    map{if ($temp[$_ + 1] ne "1" && $temp[$_ + 1] ne "NA"){push(@values,$temp[$_ + 1])}} (1..($snp_index-2));
   }
 }
 # return average Jaccard index:
 if (scalar(@values) > 0) {
  my $sum = 0;
  map{$sum+=$_} (@values);
  return sprintf "%.1f", $sum/scalar(@values);
 } 
 return 0;
}


# =================================================================
# Creates HTML for a table cell (heatmap, button for opening popup)
# =================================================================

sub heatmap_rep {
 my $heat = shift @_;
 my $link_image = "images/fp_button.png";
 my $sim_image  = "images/sim_button.png";
 my $gen_image  = "images/gen_button.png";

 my $popup = &create_popup($heat,$datadir);

 my @samples = split(",",$reports{$heat}->{title});
 my @labels  = map{$flagged{samples}->{$_} ? br.label({-style=>"color:#f93b08;"},$_) : br.label($_)} @samples;

 return td(img({-src=>$reports{$heat}->{img},
                -width=>500,
                -height=>500,
                -alt=>'Heatmap_'.$heat}),br,
           image_button({-src=>$link_image,
                -width=>111,
                -height=>32,
                -alt=>"clickglyph",
                -name=>"fingers_$heat",
                -onClick=>"showFingerprints(\'$popup\')",
                -value=>$heat,
                -align=>'MIDDLE'}),
           a({-href=>$reports{$heat}->{matrix},-target=>'_new'},
           img({-src=>$sim_image,
                -width=>111,
                -height=>32,
                -alt=>"matrix_glyph",
                -name=>"matrix_$heat",
                -value=>$heat,
                -align=>'LEFT'})),
           a({-href=>$reports{$heat}->{genotype},-target=>'_new'},
           img({-src=>$gen_image,
                -width=>111,
                -height=>32,
                -alt=>"genotype_glyph",
                -name=>"genotype_$heat",
                -value=>$heat,
                -align=>'LEFT'})),
           @labels);
}

# ======================================================================================
# Function for writing HTML for a popup (for a cluster #, expects image being available)
# ======================================================================================

sub create_popup {
 my($cluster_id,$dir) = @_;
 if (!$reports{$cluster_id}->{fp}) {
  return "error_popup.html";
 }

 my $popname = "fingerprints_popup_$cluster_id"."_$$".".html";
 my $pop = new IO::File(">$dir/$popname") or die "Cannot write to [>$dir/$popname]";

 print $pop start_html(-title   => "Individual Fingerprints Report $cluster_id",
                       -author  => 'pruzanov@oicr.on.ca',
                       -meta    => {'keywords'=>'sample swap detection genotype fingerprinting',
                                                'copyright'=>'&copy; 2013 OICR'},
                       -BGCOLOR => 'white');

 my @t_rows = ();
 foreach my $finger (@{$reports{$cluster_id}->{fp}}) {
  my $nopath_name = $finger->{name};
  $nopath_name=~s!.*/!!;

  if ($flagged{files}->{$finger->{name}}) {
   push(@t_rows,Tr({-align=>'LEFT', -valign=>'BOTTOM'},(td(img({-src=>$finger->{img},-alt=>'Fingerprint '.$finger->{img}})),
                                                        td({'style'=>"font-size:small; color:#ff0000;"},label($nopath_name)))));
   print STDERR "FLAGGED File found!\n" if DEBUG;
  }else{
   push(@t_rows,Tr({-align=>'LEFT', -valign=>'BOTTOM'},(td(img({-src=>$finger->{img},-alt=>'Fingerprint '.$finger->{img}})),
                                                        td({'style'=>"font-size:small;"},label($nopath_name)))));
  } 
 }

 print $pop table({-border      =>0,
                   -cellpadding =>0,
                   -cellspacing =>0},
                   @t_rows);

 print $pop end_html;
 $pop->close;
 return $popname;
}


#==================SWAP DETECTION CODE================

=head3 getNodes

 Function for getting hash with dendrogram nodes, linked to each other
 Only branch info would allow to determine the parent node (the h will be the largest)

=cut

sub getNodes {

 my %nodes = ();
 my @dendro = @{shift @_};
 my $count  = 0;
 my $id     = 0;

 my @parents = ();    # will have a root node as element 0, other elements change from branch to branch
 my %levels  = ();    # track the depth of tree (key = number of padding symbols until '[dendro', key - level

 map{if(/(.+)\[dendrogram/){$levels{length($1)} = 1}} @dendro;
 map{$levels{$_} = $count++} (sort {$a<=>$b} keys %levels);
 map{push(@parents,0)} (keys %levels);
 my $level = 0;

 foreach my $line(@dendro) {
  chomp($line);

  if ($line =~/(.+)\[dendrogram.*h = (\S+)\]/) {
    $level = $levels{length($1)};
    $nodes{++$id} = {dist     => $2,
                     branches => [],
                     leafs    => []};
    $parents[$level] = $id;
    push (@{$nodes{$parents[$level - 1]}->{branches}}, $id) if $level > 0;
  } elsif ($line=~/--leaf.*\"(\S+?)\"/) {
    push (@{$nodes{$parents[$level]}->{leafs}}, $1);
    $flagged{files}->{$1} = 1;
    if ($line=~/\"(\w{3,6}_\d+)_/) {
      $flagged{samples}->{$1} = 1;
    }
  }
 }

 return \%nodes;
}

=head3 getLeafs

 This function would push values into global arrays @leaf_found and @ids_tested

 Recursion applied, needs id of the next root node (we rely on global var %n for that)
 checking if the node was parsed should be done elsewhere
 @ids_tested must be used for this purpose

=cut

sub getLeafs {

 my $id    = shift @_;
 push(@ids_tested, $id);

 if ($n{$id}->{leafs} && @{$n{$id}->{leafs}} > 0) { 
     print STDERR "Found Leafs for id [$id]\n" if DEBUG;
     map{print STDERR "Saw $_\n"} (@{$n{$id}->{leafs}}) if DEBUG;
     map{push(@leafs_found, $_)} (@{$n{$id}->{leafs}});
 } 
 # Node may have both branches and leafs
 if ($n{$id}->{branches} && @{$n{$id}->{branches}} > 0) {
     print STDERR "Found Branches for id [$id]:".join(" ",@{$n{$id}->{branches}})."\n" if DEBUG;
     foreach my $b (@{$n{$id}->{branches}}) {
       print STDERR "Tracing branch with id [$b]\n" if DEBUG;
       &getLeafs($b);
     }
 }
}

=head3 isSwapPresent

 This function will look into list of files (ids)
 and check if there's a putative sample swap
 
 If a sub-cluster of files pertaining to one donor has more than half of all
 files for this donor, files get unflagged, donor still flagged as w/swap

 Will also look at special cases when a small (less than 2) number of files
 are mixed with a larger cluster and unflag larger claster if it is complete
 (includes all files for a donor) 

=cut


sub isSwapPresent {

 # Pass all arrays/hashes as refs 
 my ($test_id, $list) = @_;
 my %found_donors = ();
 map{if (/^(\w{3,6}_\d+)_/){$found_donors{$1}++}} (@{$list});

 if (scalar(keys %found_donors) > 1) {
    # Special Case when small number (up to 2) of files mix with valid large cluster
    if (scalar(keys %found_donors) == 2) {
       my @sizes    = map{$found_donors{(keys %found_donors)[$_]}} (0..1);
       my @complete = map{$sizes[$_] == $sample_counter{(keys %found_donors)[$_]} ? 1 : 0} (0..1);
       my $unflag = -1;

       if ($sizes[0]/$sizes[1] >= 2 && $complete[0] && $sizes[0] > 2) {
         $unflag = 0;
       } elsif ($sizes[1]/$sizes[0] >= 2 && $complete[1] && $sizes[1] > 2) {
         $unflag = 1;
       }

       # Unflagging larger complete sub-cluster
       if ($unflag > 0) {
         $flagged{samples}->{(keys %found_donors)[$unflag]} = undef;
         map{if (/^(\w{3,6}_\d+)_/ && $1 eq (keys %found_donors)[$unflag]){$flagged{files}->{$_} = undef;}}  @{$list}
       }
    }
    print STDERR "Node [$test_id] is invalid, need to trace deeper\n" if DEBUG;
    return 1;
 } elsif (scalar(keys %found_donors) == 1) {
   my $total = $sample_counter{(keys %found_donors)[0]}; 
   if ($found_donors{(keys %found_donors)[0]} == $total) {
        $flagged{samples}->{(keys %found_donors)[0]} = undef;
   }
   return $found_donors{(keys %found_donors)[0]} > floor($total/2) ? 0 : 1;
 } else {
   print STDERR "Node [$test_id] is invalid, no valid donors found\n" if DEBUG;
   return 1;
 }

}

